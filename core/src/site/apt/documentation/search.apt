 ---
 {Ehcache Search}
 ---

Search

%{toc|fromDepth=2|toDepth=2}

* Ehcache Search API

    (This feature is pre-release. It is in ehcache-core trunk. Maven builds for version 2.3.1-SNAPSHOT are published to
    oss.sonatype.org.)

    The Ehcache Search API allows you to execute arbitrarily complex queries against either a standalone cache or a Terracotta
    clustered cache with pre-built indexes.


*   Sample

    {{{http://github.com/downloads/sharrissf/Ehcache-Search-Sample/ehcache-search-sample-0.0.1-SNAPSHOT-distribution.tar.gz}Download}} a self-contained sample
    or check out the source:

---
git clone git://github.com/sharrissf/Ehcache-Search-Sample.git
---
   
*  What is searchable?

    Searches can be performed against both Element keys and values.
     
    Element keys and values are made searchable by extracting attributes out of the values.
    It is the attributes which are searchable.

    
    Here is simple example of a value search which queries two attributes, gender and age to
    return cache keys for 32 year old males. 
    
---
    Query query = cache.createQuery().includeKeys().add(and(age.eq(32), gender.eq("male")));
---    


    
**  Attribute Extractors  
  
    Attributes are extracted from keys or values. This is done on <<<put()>>> into the cache
    using <<<AttributeExtractor>>>s.

    Extracted attributes must be one of the following types:
    
        *   Boolean
        
        *   Byte
        
        *   Character
        
        *   Double
        
        *   Float
        
        *   Integer
        
        *   Long
        
        *   Short 
        
        *   String
        
        *   Date
        
    If an attribute cannot be extracted due to not being found or of being the wrong type an AttributeExtractorException is thrown
    after the 

*** ReflectionAttributeExtractor

    The ReflectionAttributeExtractor is a built-in search attribute extractor.

    In the simple case, where keys and/or values are already a supported type, they can be declared searchable with:

---
    <searchAttribute name="key"/> for they key, and
    <searchAttribute name="value"/> for the value
---

    Where a JavaBean property is available and it is of a searchable type, it can be simply declared using:

---
<cache>
    <searchAttribute name="age"/>
</cache>
---

  Finally, when things get more complicated, we have an expression language using method/value dotted expression chains.

  The expression chain must start with one of either "key", "value", or "element". From the starting object
  a chain of either method calls or field names follows. Method calls and field names can be freely mixed in the chain.

  Some more examples:

---
<cache>
    <searchAttribute name="age" expression="value.person.getAge()"/>
</cache>
---

---
<cache>
    <searchAttribute name="name" expression="element.toString()"/>
</cache>
---

  The method and field name portions of the expression are case sensitive
        
    
    
*** Custom AttributeExtractor
    
---
<cache name="cache1" maxElementsInMemory="0" eternal="true" overflowToDisk="false">
    <searchAttribute name="age" expression="value.getAge()"/>
    <searchAttribute name="gender" expression="value.getGender()"/>
    <searchAttribute name="name" expression="value.getName()"/>
</cache>
---  
  

---  
<cache name="cache2" maxElementsInMemory="0" eternal="true" overflowToDisk="false">
    <searchAttribute name="age" class="net.sf.ehcache.search.TestAttributeExtractor"/>
    <searchAttribute name="gender" expression="value.getGender()"/>
</cache>
---  
  
  

**  Queries

***  DSL Conventions

Queries are created using our search Domain Specific Language ("DSL"). We follow the conventions for implementing a DSL in Java
such as fluent builders and static factory methods for a compact and easy-to-read representation.

See {{http://www.infoq.com/articles/internal-dsls-java}} for a description of these conventions.


---
    Results results = cache.createQuery().add(age.eq(35)).includeKeys().execute();
---


  A query can be executed and then modified and re-executed. If <<<end>>> is called
  the query is made immutable.

  Both Element keys and attributes of Element can be queried. Attributes must be pre-defined
  for a cache.

  They are populated by extraction from an Element's value using <<<net.sf.ehcache.search.attribute.AttributeExtractor>>>. See
  extractors below.


**  Aggregators

    Aggregators are added with <<<query.includeAggregator(Aggregator aggregator, Attribute<?> attribute)>>>.

    Because the state of the cache can change between search executions it is recommended to add all of the Aggregators you want
    for a query at once. Execution is also more efficient.



** Search Results

  Queries return a <<<Results>>> object which contain objects of class <<<Result>>>.

*** How much to return

  Query results can potentially be very large and could be too large to safely return to the caller.

  Either all results can be returned using <<<results.all()>>> to get the all in one chunk, or a range of results
  using <<<results.range(int start, int count)>>> to achieve paging.

  When you are done with the results, it is recommended to call <<<discard()>>>. This allows resources to be freed.
  In the distributed implementation with Terracotta, resources may be used to hold results for paging or return.

  A list of type <<<Result>>> is the return type of each call. This type holds all types of results. To determine
  what was returned by the query if you are unsure, <<<Results>>> has boolean methods which will tell you whether
  that type of reuslt was returned.

*** Result

   A Result object can contain either:

   *    the Element key - use <<<includeKeys()>>> in the query

   *    the Element value - use <<<includeValues()>>> in the query

   *    predefined attribute(s) extracted from an Element value - use <<<includeAttribute(...)>>> in the query.

   *    Aggregator functions - use <<<includeAggregate()>>> in the query

   For attributes and functions, Result must be called with the templated type.

**   Limiting the size of Results

    By default a query will return an unlimited number of results. For example the following
    query will return all keys in the cache.
    
---
    Query query = cache.createQuery();
    query.includeKeys();
    query.execute();
---

    If too many results are returned it could cause an OutOfMemoryError 
    
    The <<<maxResults>>> clause is used to limit the size of the results.
    
    e.g. to limit the above query to the first 100 elements found:

---
    Query query = cache.createQuery();
    query.includeKeys();
    query.maxResults(100);
    query.execute();
---


*   Implementations

**  Standalone Ehcache

    The standalone Ehcache implementation does not use indexes. It uses fast iteration of the cache
    instead, relying on the very fast access to essentially do the equivalent of a table scan for each
    query.

    Attributes are not extracted ahead of time. They are done during query execution.


*** Performance

    Search operations perform in O(n) time.

    Accordingly, this implementation is suitable for development and testing. For production it is recommended to only
    search against caches that are less than 100,000 element in size.

    An indexed implementation may be done in future.

**  Ehcache backed by the Terracotta Server Array

    This implementation uses Lucene indexes which are maintained on each Terracotta server. In Ehcache EX the index is
    on a single active server. In Ehcache FX the cache is sharded across the number of active nodes in the cluster. The index
    for each shard is maintained on that shard's server.

    Searches are performed using the Scatter-Gather pattern. The query executes on each node and the results are then aggregated
    back in the Ehcache that initiated the search.

*** Performance

    Search operations perform in O(log n / number of shards) time.

    Performance is excellent and can be improved simply by adding more servers to the FX array.

*** Network Effects

    Search results are returned over the network. The data returned could potentially be very large, so
    techniques to limit return size are recommended such as:

    * limiting the results with <<<maxResults>>> or using the paging API <<<Results.range(int start, int length)>>>

    * Returning keys instead of values using <<<includeKeys()>>> in the query

    * Returning attributes instead of values

    * using a built-in <<<Aggregator>>> function when you only need a summary statistic



*   Limitations in the alpha release

    The above documentation is written for how we see search working when it is released.

    In the interests of getting this out into alpha testers hands there are a few things we plan to do which are not yet done:

    * performance optimisations for standalone have not been done

    * Added a test which shows that getValue() does not work unless includeKeys() is on.  Bug EHC-799"

    * Added EHC-800 comment to ehcache-search.xml. Not honouring JavaBeans convention

    * EHC-801: Keys and values which are already of a supported attribute type should be able to be added to queries using the attribute name "key"

    * EHC-802: result.getValue() should not work unless includeValues() was specified.

    * EHC-803: Missing implemenations in Results and Result


