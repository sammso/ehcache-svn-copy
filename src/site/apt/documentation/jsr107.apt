JSR107 (JCACHE) Support

* {JSR107 Implementation}

    Ehcache provides an implementation of JSR107 via the <<<net.sf.cache.jcache>>> package.

* Problems With JSR107

    If you are using ehcache through the jcache interface you need to be aware of some problems
    and limitations in the specification.


** Entry
-------
    int getHits();
-------

    Bugs have been reported against ehcache for using ints for hits. Some usages require longs

    Once you get to Integer.MAX_VALUE the counter rolls over. See the following test:


-----
    public void testIntOverflow() {
        long value = Integer.MAX_VALUE;
        value += Integer.MAX_VALUE;
        value += 5;
        LOG.info("" + value);
        int valueAsInt = (int) value;
        LOG.info("" + valueAsInt);
        assertEquals(3, valueAsInt);
    }
-----


** javax.cache.CacheStatistics

    *   getObjectCount() is a strange name. How about getSize()? If a cache entry is an object graph
        each entry will have more than one "object" in it. But the cache size is what is really meant,
        so why not call it that?

---------


public interface CacheStatistics {

    public static final int STATISTICS_ACCURACY_NONE = 0;
    public static final int STATISTICS_ACCURACY_BEST_EFFORT = 1;
    public static final int STATISTICS_ACCURACY_GUARANTEED = 2;

    public int getStatisticsAccuracy();

    public int getObjectCount();

    public int getCacheHits();

    public int getCacheMisses();

    public void clearStatistics();

---------

    Once again <<<getCacheHits>>> and <<<getCacheMisses>>> should be longs.


** CacheListener

-----

    /**
     *  Interface describing various events that can happen as elements are added to
     *  or removed from a cache
     */
    public interface CacheListener {
        /** Triggered when a cache mapping is created due to the cache loader being consulted */
        public void onLoad(Object key);

        /** Triggered when a cache mapping is created due to calling Cache.put() */
        public void onPut(Object key);

        /** Triggered when a cache mapping is removed due to eviction */
        public void onEvict(Object key);

        /** Triggered when a cache mapping is removed due to calling Cache.remove() */
        public void onRemove(Object key);

        public void onClear();
    }

-----

    Listeners often need not just the key, but the cache Entry itself. This listener interface
    is extremely limiting.



** javax.cache.CacheFactory

    A property is specified in the resource services/javax.cache.CacheFactory for a CacheFactory.

    The factory then resolves the CacheManager which must be a singleton.

    A singleton CacheManager works in simple scenarios. But there are many where you want multiple
    CacheManagers in an application. Ehcache supports both singleton creation semantics and
    instances and defines the way both can coexist.

    The singleton CacheManager is a limitation of the specification.

    (Alternatives: Some form of annotation and injection scheme)

    

** javax.cache.CacheManager

    CacheManager does not have the following features:

    shutdown the CacheManager - there is no way to free resources or persist. Implementations
    may utilise a shutdown hook, but that does not work for application server redeployments,
    where a shutdown listener must be used

    remove caches from the CacheManager - once its there it is there until JVM shutdown. This does
    not work well for dynamic creation, destruction and recreation of caches.



** javax.cache.Cache

    *   The spec is silent on whether a Cache can be used in the absence of a CacheManager. Requiring
        a CacheManager makes a central place where concerns affecting all caches can be managed, not
        just a way of looking them up. For example, configuration for persistence and distribution.

    *   Cache does not have a lifecycle. There is no startup and no shutdown. There is no way, other than
        a shutdown hook, to free resources or perform persistence operations. Once again this will not
        work for redeployment of applications in an app server.

    *   There is no mechanism for creating a new cache from a default configuration such as
        a <<<public void registerCache(String cacheName)>>> on CacheManager. This feature is considered
        indispensable by frameworks such as Hibernate.

    *   Cache does not have a <<<getName()>>> method. A cache has a name; that is how it is retrieved
        from the CacheManager. But it does not know its own name. This forces API users to keep track
        of the name themselves for reporting exceptions and log messages.







    
    


