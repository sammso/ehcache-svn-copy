 ---
 {Ehcache Search}
 ---

Search

%{toc|fromDepth=2|toDepth=2}

* Ehcache Search API

    (This feature is pre-release. It is in ehcache-core trunk. Maven builds for version 2.4.0-SNAPSHOT are published to
    oss.sonatype.org.)

    The Ehcache Search API allows you to execute arbitrarily complex queries against either a standalone cache or a Terracotta
    clustered cache with pre-built indexes. Searchable attributes may be extracted from both keys and values. Keys, values,
     or summary values (Aggregators) can all be returned.


    Here is a simple example: Search for 32 year old males and return the cache values.

---
    Results results = cache.createQuery().includeValues().add(and(age.eq(32), gender.eq("male"))).execute();
---

*  What is searchable?

    Searches can be performed against both Element keys and values.
     
    Element keys and values are made searchable by extracting attributes with supported search types out of the values.

    It is the attributes themelves which are searchable.

*   How to make a cache searchable

**  By Configuration

    Caches are made searchable by adding a \<searchable/\> tag to the ehcachel.xml.

---
    <cache name="cache2" maxElementsInMemory="10000" eternal="true" overflowToDisk="false">
        <searchable/>
    </cache>
---

    This configuration will scan keys and vales and if they are of supported search types, add them as
    attributes called "key" and "value" respectively.

    Lots of times these will not be directly searchable and instead you will need to extract searchable attributes out of them.
    The following example shows this more typical case.  Attribute Extractors are explained in more detail in the following section.

---
    <cache name="cache3" maxElementsInMemory="10000" eternal="true" overflowToDisk="false">
        <searchable>
            <searchAttribute name="age" class="net.sf.ehcache.search.TestAttributeExtractor"/>
            <searchAttribute name="gender" expression="value.getGender()"/>
        </searchable>
    </cache>

---

**  Programmatically

    You can create new <<<SearchAttribute>>>s and add them to your cache configuration, and then create your cache.

    This example shows how:

---
        CacheConfiguration cacheConfig = new CacheConfiguration("test", -1).eternal(true);

        // Create attributes on the stuff we want to be able to search on.
        // You can use an expression for getting at the value to be indexed on a cache or you can code your own

        // Expression
        SearchAttribute sa = new SearchAttribute();
        sa.setExpression("value.getAge()");
        sa.setName("age");
        cacheConfig.addSearchAttribute(sa);

        // Coding your own
        sa = new SearchAttribute();
        sa.className("org.sharrissf.sample.EhcacheSearchPlaying$NameAttributeExtractor");
        sa.setName("name");
        cacheConfig.addSearchAttribute(sa);

        sa = new SearchAttribute();
        sa.setExpression("value.getGender()");
        sa.setName("gender");
        cacheConfig.addSearchAttribute(sa);

        sa = new SearchAttribute();
        sa.setExpression("value.getAddress().getState()");
        sa.setName("state");
        cacheConfig.addSearchAttribute(sa);

        Cache test = new Cache(cacheConfig);
        cacheManager.add(test);
---


*  Attribute Extractors
  
    Attributes are extracted from keys or values. This is done on <<<put()>>> into the cache
    using <<<AttributeExtractor>>>s in the clustered implementation and during search in the standalone implementation 

    Extracted attributes must be one of the following supported types:
    
        *   Boolean
        
        *   Byte
        
        *   Character
        
        *   Double
        
        *   Float
        
        *   Integer
        
        *   Long
        
        *   Short 
        
        *   String
        
        *   Date

        *   Enum
        
    If an attribute cannot be extracted due to not being found or of being the wrong type an AttributeExtractorException is thrown
    during the <<<put()>>> in the clustered implementation and on search execution in the standalone implementation

*** ReflectionAttributeExtractor

    The ReflectionAttributeExtractor is a built-in search attribute extractor.

    In the simple case, where keys and/or values are already a supported type, they are added automatically as attributes with the names "key" amd "value".

    Where a JavaBean property is available and it is of a searchable type, it can be simply declared using:

---
<cache>
    <searchable>
        <searchAttribute name="age"/>
    </searchable>
</cache>
---

  Finally, when things get more complicated, we have an expression language using method/value dotted expression chains.

  The expression chain must start with one of either "key", "value", or "element". From the starting object
  a chain of either method calls or field names follows. Method calls and field names can be freely mixed in the chain.

  Some more examples:

---
<cache>
    <searchable>
        <searchAttribute name="age" expression="value.person.getAge()"/>
    </searchable>
</cache>
---

---
<cache>
    <searchable>
        <searchAttribute name="name" expression="element.toString()"/>
    </searchable>
</cache>
---

  The method and field name portions of the expression are case sensitive
        
    
    
*** Custom AttributeExtractor

  In more complex situations you can create your own attribute extractor by implementing the AttributeExtractor interface. Providing your 
  extractor class is shown in the following example:
    
---  
<cache name="cache2" maxElementsInMemory="0" eternal="true" overflowToDisk="false">
    <searchable>
        <searchAttribute name="age" class="net.sf.ehcache.search.TestAttributeExtractor"/>
    </searchable>
</cache>
---  
  
*  Search Query Language

    Ehcache Search introduces an Object Oriented query language, following DSL principles, which should feel familiar and natural to Java programmers.

    Here is a simple example:

---
    Query query = cache.createQuery().add(age.eq(35)).includeKeys().end();
    Results results = query.execute();
---

** Making queries immutable

  By defualt a query can be executed and then modified and re-executed. If <<<end>>> is called
  the query is made immutable.

**  Using attributes in queries

  If available the built-in key and value attributes are referenced as follows:

---
    Attribute key = cache.getSearchAttribute(Query.KEY);
    Attribute value = cache.getSearchAttribute(Query.VALUE);
    Results results = cache.createQuery().add(key.eq(35)).execute();
---

    Other attributes are referenced by the names given them in the configuration. E.g.

---
   Attribute<Integer> age = cache.getSearchAttribute("age");
   Attribute<String> gender = cache.getSearchAttribute("gender");
   Attribute<String> name = cache.getSearchAttribute("name");
---

** Expressions

    The Query to be searched for is built up using Expressions.

    Expressions include logical operators such as <and> and <or>. It also includes comparsion operators such as <ge>, <between> and <like>

    <<<add(...)>>> is used to add a clause to a query. Adding a further clause automatically <and>s the clauses

---
    query = cache.createQuery().includeKeys().add(age.le(65)).add(gender.eq("male")).end();
---

   See the {{{http://ehcache.org/xref/net/sf/ehcache/search/expression/package-frame.html}Expression JavaDoc}} for a complete list.


**   Limiting the size of Results

    By default a query will return an unlimited number of results. For example the following
    query will return all keys in the cache.

---
    Query query = cache.createQuery();
    query.includeKeys();
    query.execute();
---

    If too many results are returned it could cause an OutOfMemoryError

    The <<<maxResults>>> clause is used to limit the size of the results.

    e.g. to limit the above query to the first 100 elements found:

---
    Query query = cache.createQuery();
    query.includeKeys();
    query.maxResults(100);
    query.execute();
---


* Search Results

  Queries return a <<<Results>>> object which contain objects of class <<<Result>>>.

** How much to return

  Query results can potentially be very large and could be too large to safely return to the caller.

  Either all results can be returned using <<<results.all()>>> to get the all in one chunk, or a range of results
  using <<<results.range(int start, int count)>>> to achieve paging.

  When you are done with the results, it is recommended to call <<<discard()>>>. This allows resources to be freed.
  In the distributed implementation with Terracotta, resources may be used to hold results for paging or return.

  A list of type <<<Result>>> is the return type of each call. This type holds all types of results. To determine
  what was returned by the query if you are unsure, <<<Results>>> has boolean methods which will tell you whether
  that type of reuslt was returned.

** Result

   A Result object can contain either:

   *    the Element key - use <<<includeKeys()>>> in the query

   *    the Element value - use <<<includeValues()>>> in the query

   *    predefined attribute(s) extracted from an Element value - use <<<includeAttribute(...)>>> in the query.

   Aggregator functions - use <<<includeAggregate()>>> in the query. The aggregator result is avaia

   For attributes, Result must be called with the templated type.


**  Aggregators

    Aggregators are added with <<<query.includeAggregator(Aggregator aggregator, Attribute<?> attribute)>>>.

    Because the state of the cache can change between search executions it is recommended to add all of the Aggregators you want
    for a query at once. Execution is also more efficient.

    See the {{{http://ehcache.org/xref/net/sf/ehcache/search/aggregator/package-frame.html}Aggregators JavaDoc}} for a complete list.


*   Sample Application

    We have created a simple standalone sample application with few dependencies for you to easily get started with Ehcache Search.

    {{{http://github.com/downloads/sharrissf/Ehcache-Search-Sample/ehcache-search-sample-0.0.1-SNAPSHOT-distribution.tar.gz}Download}} it
    or check out the source:

---
git clone git://github.com/sharrissf/Ehcache-Search-Sample.git
---

    The {{{http://ehcache.org/xref-test/net/sf/ehcache/search/package-summary.html}Ehcache Test Sources}} show lots of further examples
    on how to use each Ehcache Search feature.

*   Scripting Environments

    Ehcache Search is readily amenable to scripting. The following example shows how to use it with BeanShell:

---
   Interpreter i = new Interpreter();

    //Auto discover the search attributes and add them to the interpreter's context
    Map<String, SearchAttribute> attributes = cache.getCacheConfiguration().getSearchAttributes();
    for (Map.Entry<String, SearchAttribute> entry : attributes.entrySet()) {
        i.set(entry.getKey(), cache.getSearchAttribute(entry.getKey()));
        LOG.info("Setting attribute " + entry.getKey());
    }

    //Define the query and results. Add things which would be set in the GUI i.e. includeKeys and add to context
    Query query = cache.createQuery().includeKeys();
    Results results = null;
    i.set("query", query);
    i.set("results", results);

    //This comes from the freeform text field
    String userDefinedQuery = "age.eq(35)";

    //Add the stuff on that we need
    String fullQueryString = "results = query.add(" + userDefinedQuery + ").execute()";

    i.eval(fullQueryString);
    results = (Results) i.get("results");
    assertTrue(2 == results.size());
    for (Result result : results.all()) {
        LOG.info("" + result.getKey());
    }
---

*   Implementations

**  Standalone Ehcache

    The standalone Ehcache implementation does not use indexes. It uses fast iteration of the cache
    instead, relying on the very fast access to essentially do the equivalent of a table scan for each
    query.

    Attributes are not extracted ahead of time. They are done during query execution.


*** Performance

    Search operations perform in O(n) time.

    Accordingly, this implementation is suitable for development and testing. For production it is recommended to only
    search against caches that are less than 100,000 element in size.

    An indexed implementation may be done in future.

**  Ehcache backed by the Terracotta Server Array

    This implementation uses Lucene indexes which are maintained on each Terracotta server. In Ehcache EX the index is
    on a single active server. In Ehcache FX the cache is sharded across the number of active nodes in the cluster. The index
    for each shard is maintained on that shard's server.

    Searches are performed using the Scatter-Gather pattern. The query executes on each node and the results are then aggregated
    back in the Ehcache that initiated the search.

*** Performance

    Search operations perform in O(log n / number of shards) time.

    Performance is excellent and can be improved simply by adding more servers to the FX array.

*** Network Effects

    Search results are returned over the network. The data returned could potentially be very large, so
    techniques to limit return size are recommended such as:

    * limiting the results with <<<maxResults>>> or using the paging API <<<Results.range(int start, int length)>>>

    * Returning keys instead of values using <<<includeKeys()>>> in the query

    * Returning attributes instead of values

    * using a built-in <<<Aggregator>>> function when you only need a summary statistic



*   Limitations in the alpha release

    The above documentation is written for how we see search working when it is released.

    In the interests of getting this out into alpha testers hands there are a few things we plan to do which are not yet done:

    * performance optimisations for standalone have not been done

    * Added a test which shows that getValue() does not work unless includeKeys() is on.  Bug EHC-799"

    * Added EHC-800 comment to ehcache-search.xml. Not honouring JavaBeans convention

    * EHC-801: Keys and values which are already of a supported attribute type should be able to be added to queries using the attribute name "key" and "value"

    * EHC-802: result.getValue() should not work unless includeValues() was specified.

    * EHC-803: Missing implemenations in Results and Result

    * EHC-804:  Add <searchable> sub-element to ehcache.xml to enclose search configuration




TODO:

- Use fluent interface methods in programatic example for search attributes

- create a V2 section
  - add back includeValues() that is orthogonal to includeKeys() and can
    be more effecient network wise for round trips

- update aggregator section for new style of things
