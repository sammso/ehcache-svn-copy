JSR107 (JCACHE) Support

* {JSR107 Implementation}

    Ehcache provides an implementation of JSR107 via the <<<net.sf.cache.jcache>>> package.

* Problems With Specific Interfaces in JSR107

    If you are using ehcache through the jcache interface you need to be aware of some problems
    and limitations in the specification.




** net.sf.jsr107cache.CacheManager

    CacheManager does not have the following features:

    *   shutdown the CacheManager - there is no way to free resources or persist. Implementations
        may utilise a shutdown hook, but that does not work for application server redeployments,
        where a shutdown listener must be used.

    *   List caches in the CacheManager. There is no way to iterate over, or get a list of caches.

    *   remove caches from the CacheManager - once its there it is there until JVM shutdown. This does
        not work well for dynamic creation, destruction and recreation of caches.



** net.sf.jsr107cache.CacheFactory

    A property is specified in the resource services/net.sf.jsr107cache.CacheFactory for a CacheFactory.

    The factory then resolves the CacheManager which must be a singleton.

    A singleton CacheManager works in simple scenarios. But there are many where you want multiple
    CacheManagers in an application. Ehcache supports both singleton creation semantics and
    instances and defines the way both can coexist.

    The singleton CacheManager is a limitation of the specification.

    (Alternatives: Some form of annotation and injection scheme)


**  net.sf.jsr107cache.Cache

    *   The spec is silent on whether a Cache can be used in the absence of a CacheManager. Requiring
        a CacheManager makes a central place where concerns affecting all caches can be managed, not
        just a way of looking them up. For example, configuration for persistence and distribution.

    *   Cache does not have a lifecycle. There is no startup and no shutdown. There is no way, other than
        a shutdown hook, to free resources or perform persistence operations. Once again this will not
        work for redeployment of applications in an app server.

    *   There is no mechanism for creating a new cache from a default configuration such as
        a <<<public void registerCache(String cacheName)>>> on CacheManager. This feature is considered
        indispensable by frameworks such as Hibernate.

    *   Cache does not have a <<<getName()>>> method. A cache has a name; that is how it is retrieved
        from the CacheManager. But it does not know its own name. This forces API users to keep track
        of the name themselves for reporting exceptions and log messages.

    *   Cache does not support setting a TTL override on a put. e.g. <<<put(Object key, Object value, long timeToLive)>>>.
        This is a useful feature.

    *   The spec is silent on whether the cache accepts null keys and elements. Ehcache allows all implementations. i.e.

------
        cache.put(null, null);
        assertNull(cache.get(null));
        cache.put(null, "value");
        assertEquals("value", cache.get(null));
        cache.put("key", null);
        assertEquals(null, cache.get("key"));
------

        <<<null>>> is effectively a valid key. However because <<<null>>> id not an instance of <<<Serializable>>> null-keyed
        entries will be limited to in-process memory.


    *   The <<<load(Object key)>>>, <<<loadAll(Collection keys)>>> and <<<getAll(Collection collection)>>> methods
        specify in the javadoc that they should be asynchronous. Now, most load methods work off a database or some other
        relatively slow resource (otherwise there would be no need to have a cache in the first place).

        To be asynchronous, each 




**  net.sf.jsr107cache.CacheEntry

    *   getHits() returns int. It should return long because production cache systems have entries hit more
        than Integer.MAX_VALUE times.

        Once you get to Integer.MAX_VALUE the counter rolls over. See the following test:


-----
    public void testIntOverflow() {
        long value = Integer.MAX_VALUE;
        value += Integer.MAX_VALUE;
        value += 5;
        LOG.info("" + value);
        int valueAsInt = (int) value;
        LOG.info("" + valueAsInt);
        assertEquals(3, valueAsInt);
    }
-----


** net.sf.jsr107cache.CacheStatistics

    *   getObjectCount() is a strange name. How about getSize()? If a cache entry is an object graph
        each entry will have more than one "object" in it. But the cache size is what is really meant,
        so why not call it that?


    *   Once again <<<getCacheHits>>> and <<<getCacheMisses>>> should be longs.


---------


public interface CacheStatistics {

    public static final int STATISTICS_ACCURACY_NONE = 0;
    public static final int STATISTICS_ACCURACY_BEST_EFFORT = 1;
    public static final int STATISTICS_ACCURACY_GUARANTEED = 2;

    public int getStatisticsAccuracy();

    public int getObjectCount();

    public int getCacheHits();

    public int getCacheMisses();

    public void clearStatistics();

---------


    *   There is a <<<getStatisticsAccuracy()>>> method but not a corresponding setStatisticsAccuracy
        method on Cache, so that you can alter the accuracy of the Statistics returned.

        Ehcache supports this behaviour.

    *   There is no method to estimate memory use of a cache. Ehcache serializes each Element to a
        byte[] one at a time and adds the serialized sizes up. Not perfect but better than nothing
        and works on older JDKs.

    *   CacheStatistics is obtained using <<<cache.getCacheStatistics()>>> It then has getters for values.
        In this way it feels like a value object. The ehcache implementation is Serializable so that
        it can act as a DTO. However it also has a clearStatistics() method. This method clear counters
        on the Cache. Clearly CacheStatistics must hold a reference to Cache to enable this to happen.

        But what if you are really using it as a value object and have serialized it? The ehcache implementation marks the Cache
        reference as <<<transient>>>. If clearStatistics() is called when the cache reference is no longer
        there, an IllegalStateException is thrown.

        A much better solution would be to move clearStatistics() to Cache.

** net.sf.jsr107cache.CacheListener

-----

    /**
     *  Interface describing various events that can happen as elements are added to
     *  or removed from a cache
     */
    public interface CacheListener {
        /** Triggered when a cache mapping is created due to the cache loader being consulted */
        public void onLoad(Object key);

        /** Triggered when a cache mapping is created due to calling Cache.put() */
        public void onPut(Object key);

        /** Triggered when a cache mapping is removed due to eviction */
        public void onEvict(Object key);

        /** Triggered when a cache mapping is removed due to calling Cache.remove() */
        public void onRemove(Object key);

        public void onClear();
    }

-----

    *   Listeners often need not just the key, but the cache Entry itself. This listener interface
        is extremely limiting.

    *   Ehcache has a removeAll notification. There is no analogue in JCACHE. No notification is done.




*   Other Areas

**  JMX

     JSR107 is silent on JMX which has been included in the JDK since 1.5.






    
    


