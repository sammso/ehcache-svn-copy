J2EE Servlet Caching

    Some ehcache users may not have heard of this capability. It was previously included in the ehcache-constructs module, a separate
    download from ehcache.sf.net. It also had separate documentation. With ehcache-1.2.1, it is merged into the main module. This
    code has been used in production for more than 2 years and is very mature.


* {CachingFilter}

    You want to use the BlockingCache with web pages, but the requirement to always release the lock creates gnarly code.
    You also want to think about what you are doing withs involved. This is on every jsp:include and every Servlet. And you can
    programmatically add your own. If you have content generated by JSP, Velocity, XSLT, Servlet output or anything else,
    it can all be cached by CachingFilter. A separation of concerns.

    How do you determine what the key of a page is? The filter has an abstract calculateKey method, so it is up to you.

    You notice a problem and an opportunity. The problem is that the web pages you are caching are huge. That chews up
    either a lot of memory (Memoryout thinking about the caching.

    Enter the CachingFilter, a Servlet 2.3 compliant filter. Why not just do a JSP tag library, like OSCache? The answer
    is that you want the caching of your responses to be independent of the rendering technology. The filter chain is
    reexcuted every time a RequestDispatcher iStore) or a lot of disk space (DiskStore). Also you notive that these pages take their
    time going over the Internet. The opportunity is that you notice that all modern browsers support gzip encoding. A survey
    of logs reveals that 85% of the time the browser accepts gzipping. (The majority of the 15% that does not is IE
    behind a proxy). Ok, so gzip the response before caching it. Ungzipping is fast - so just ungzip for the 15% of the
    time the browser does not accept gzipping.


* {SimplePageCachingFilter}

    What if you just want to get started with the CachingFilter and don't want to think too hard? Just use SimplePageCachingFilter
    which has a calculateKey method already implemented. It uses <<<httpRequest.getRequestURI()).append(httpRequest.getQueryString()>>>
    for the key. This works most of the time. It tends to get less effective when referrals and affiliates are added to the query,
    which is the case for a lot of e-commerce sites.

    SimplePageCachingFilter is 10 lines of code.

* {PageFragmentCachingFilter}

    You notice that an entire page cannot be cached because the data on it vary in staleness. Say, an address which changes
    very infrequently, and the price and availability of inventory, which changes quite a lot. Or you have a portal, with
    lots of components and with different stalenesses. Or you use the replicated cache functionality in ehcache and you
    only want to rebuild the part of the page that got invalidated.

    Enter the PageFragmentCachingFilter. It does everyting that SimplePageCachingFilter does, except it never
    gzips, so the fragments can be combined.


* {SimplePageFragmentCachingFilter}

    What if you just want to get started with the PageFragmentCachingFilter and don't want to think too hard? Just use SimplePageFragmentCachingFilter
    which has a calculateKey method already implemented. It uses <<<httpRequest.getRequestURI()).append(httpRequest.getQueryString()>>>
    for the key. This works most of the time. It tends to get less effective when referrals and affiliates are added to the query,
    which is the case for a lot of e-commerce sites.

    SimplePageFragmentCachingFilter is 10 lines of code.
