 ---
 Off-heap Store
 ---

{Off-heap Store}

    The off-heap store permits a cache to use a new type of memory store which is implemented using the <<<DirectByteBuffer>>> class,
    which has been available on all JVMs since JDK1.4.

    It allows very large caches to be created (we have tested up to 256GB). Because the data is stored in bytes, there are two
    implications:

    * only Serializable cache keys and values can be placed in the store, similar to DiskStore

    * Serialization and deserialization take place on putting and getting from the store. As a result, the off-heap store
      is around 10 times slower than the MemoryStore. It is still 100 times faster than the DiskStore because there is use of
      hard disk.

    The Off-heap store is only available as an the BigMemory add-on to Enterprise Ehcache.


*   Configuration

**  Configuring caches to overflow to off-heap.

    Configuring a cache to use an off-heap store can be done either through XML or programmatically.

***  Declarative Configuration

    The following XML configuration creates an offheap-cache with a in-heap store (maxElementsInMemory) of 10,000 elements which
    overflow to a 1-gigabyte off-heap area.

---
    <?xml version="1.0" encoding="UTF-8"?>
    <ehcache updateCheck="false" monitoring="off"
             dynamicConfig="false">

        <defaultCache maxElementsInMemory="10000"
                      eternal="true"
                      memoryStoreEvictionPolicy="LRU"
                      statistics="false" />

        <cache name="sample-offheap-cache"
               maxElementsInMemory="10000"
               eternal="true"
               memoryStoreEvictionPolicy="LRU"
               overflowToOffHeap="true"
               maxMemoryOffHeap="1G"/>
    </ehcache>
---

***  Programmatic Configuration

    The equivalent cache can be created using the following programmatic configuration:

---
    public Cache createOffHeapCache() {
      CacheConfiguration config = new CacheConfiguration("sample-offheap-cache", 10000).overflowToOffHeap(true).maxMemoryOffHeap("1G");
      Cache cache = new Cache(config);
      manager.addCache(cache);
      return cache;
    }
---

**   Add The License

    The Ehcache Enterprise download kit (available here - please add URL) contains a trial license key which must be added to activate
    the off-heap store.

    It can be added in two ways:

***  In the classpath

    Add the <<<terracotta.key>>> to the root of your classpath, which is also where you add ehcache.xml. It will be
    automatically found.

***  Specify the key in a Java system property

    Add a <<<org.terracotta.ehcachedx.productkey.path>>> system property which points to the key location.

    e.g.

---
     java -Dorg.terracotta.ehcachedx.productkey.path=./terracotta.key
---


**  Allocating Direct Memory in the JVM

    In order to use these configurations you must then use the ehcache-core-ee jar on your classpath, and modify your JVM command-line
    to increase the amount of direct memory allowed by the JVM.

    e.g. to allocate 2GB of memory in the JVM.

---
    java -XX:MaxDirectMemorySize=2G -cp "ehcache-core-ee-2.3.0.jar:slf4j-api-1.5.11.jar:slf4j-jdk14-1.5.11.jar"
---


*   Sample application

    Download here a simple Maven-based application that uses the ehcache off-heap functionality.

    Note: You will need to get a license key as discussed above to run this.







* Disk

20MB per second asynchronously

Shutdown just does a flush

Startup



Questions:

Disk Access Stripes.

Exists for off-heap only. Will exist again in the future.

Deadlocks
All fixed in BlockingCache

DiskStore Persistence
If you try to persist to disk, currently you will get an OOME if you have more than a few GB.

The

21 minutes

50MB/s
8MB/s


* Puts


    Puts get into all three places.

    Yes, any cache which uses offheap puts to all levels of the cache when any put is performed.
    This means that gets which pull from the lower levels of the cache and therefore populate higher tiers
    (think pulling from offheap to onheap) don't trigger serialization when the incoming element triggers
    an eviction from the higher tier (in this case on-heap).  Since normal running for a cache would involve
    the memory store being constantly at the eviction threshold, without this we would incur serialization
    overhead on every on-heap cache miss.


    You will get an OOME on the Disk on overflow.


    Is your collective buffer full?



* Eviction Algorithms

    In-memory store eviction algorithm

    Off-heap uses a Clock Cache, a standard paging algorithm, an approximation of LRU



*   Issue

    stripe

    n segments with a lock for each in off heap. They allocate space from a pool.

    Each cache allocates all the speace it is allowed on startup. It is not used until the cache starts.

    Performance looks like a sine wave during cache filling.


    Max serialized size is 4MB. 256KB for a pathological

    8MB would 

    Assuming good hashcodes, 

*   Configuration


*   Advanced Configuration Parameters


    Set yb cerating a system property cache_Name.property_name whic hcan either be done in the command line
    or programattically. It mustb edone beofre the CacheManager is started.

    e.g. com.company.domain.State.maxOffHeapValueSize=30MB

**  maxOffHeapValueSize

    The default is 4MB.


**   -XX:+UseLargePages

    This is a JVM flag which is meant to improve performance of memory-hungry applications.
    In testing, this option gives a 5% speed improvement with a 1Gb off-heap cache.

* FAQ (to be added)

