 ---
 Cache Configuration
 ---


{Cache Configuration}

~~%{toc|fromDepth=2|toDepth=3}

    Caches can be configured in Ehcache either declaratively, in xml, or by creating them programmatically
    and specifying their parameters in the constructor.

    While both approaches are fully supported it is generally a good idea to separate the cache configuration
    from runtime use. There are also these benefits:

     * It is easy if you have all of your configuration in one place.
       Caches consume memory, and disk space. They need to be carefully tuned.
       You can see the total effect in a configuration file. You could do this
       code, but it would not as visible.

     * Cache configuration can be changed at deployment time.

     * Configuration errors can be checked for at start-up, rather than causing a runtime error.

    This chapter covers XML declarative configuration.

    Ehcache is redistributed by lots of projects. They may or may not provide a sample Ehcache XML configuration file.
    If one is not provided, download Ehcache from {{http://ehcache.org}}. It, and the ehcache.xsd is provided in
    the distibution.


* {Dynamically Changing Cache Configuration}

    After a Cache has been started its configuration is not generally changeable. However, since Ehcache 2.0,  certain aspects of
    cache configuration can modified dynamically at runtime, namely:

    * timeToLive

    * timeToIdle

    * maxElementsInMemory

    * maxElementsOnDisk

    * memory store eviciton policy

    * CacheEventListeners can be added and removed dynamically

    This example shows how to dynamically modify the cache configuration of an already running cache:

---
    Cache cache = manager.getCache("sampleCache");
    CacheConfiguration config = cache.getCacheConfiguration();
    config.setTimeToIdleSeconds(60);
    config.setTimeToLiveSeconds(120);
    config.setMaxElementsInMemory(10000);
    config.setMaxElementsOnDisk(1000000);
---

    Dynamic cache configurations can also be frozen to prevent future changes:

---
    Cache cache = manager.getCache("sampleCache");
    cache.disableDynamicFeatures();
---


*   Memory Based Cache Sizing (Ehcache 2.5 and higher)

    Historically Ehcache has only permitted sizing of caches by maxElementsInMemory for the the OnHeap Store and maxElementsOnDisk
    for the DiskStore. The OffHeap Store introduced sizing in terms of memory use.

    From Ehcache 2.5, we are extending sizing based on bytes consumed to all stores.

    The new cache attributes are:

    *   maxBytesOnHeap

    *   maxBytesOffHeap (formerly maxMemoryOffHeap)

    *   maxBytesOnDisk

    Size may be expressed in bytes using the convention for specifying -Xmx (e.g. 200k, 30m, 5g etc.)

    For added simplicity you can also specify these attributes at the ehcache level, which then applies them to the whole CacheManager,
    leaving each cache to share in one large pool of memory.

    If you specify a CacheManager wide sizes, you can also use percentages at the cache level. e.g maxBytesOnHeap="20%".

    For completeness we also add cache pinning and rules for cache-level configuration to override CacheManager level configuration.


**  Example Configuration

    An example is shown below. It allocates 1GB on heap and 4GB off heap at the CacheManager level.

    It also demonstrates some finer points which we will conver in the following sections.

---
    <ehcache maxBytesOnHeap="1g" maxBytesOffHeap="4g" maxBytesOnDisk="100g" >

       <cache name="explicitlyAllocatedCache1"
              maxBytesOnHeap="50m"
              maxBytesOffHeap="200m"
              timeToLiveSeconds="100"
       </cache>

       <cache name="explicitlyAllocatedCache2"
              maxBytesOnHeap="10%"
              maxBytesOffHeap="200m"
              timeToLiveSeconds="100"
       </cache>

       <cache name="automaticallyAllocatedCache1"
              timeToLiveSeconds="100"
              overflowToDisk="true"
       </cache>

       <cache name="automaticallyAllocatedCache2"
              timeToLiveSeconds="100"
       </cache>

       <cache name="pinnedCache"
              timeToLiveSeconds="100"
              <pinning storage="inMemory"/>
       </cache>

    </ehcache>
---

** CacheManager versus Cache level configuration

    Caches without specific configuration participate in the general storage pools. And caches with specific configuration take
    either a fixed amount (e.g. 200m) or a percentage (e.g. 5%).

    When managing storage out of CacheManager level pools, element are evicted across all caches using an LRU (possibly clock based)
    algorithm.

    The CacheManager level storage pool attributes are:

    *   maxBytesOnHeap="size"

    *   maxBytesOffHeap="size"

    *   maxBytesOnDisk="size"


       where size is the Java -Xmx syntax. e.g. 4g

    If a store is configured using a CacheManager level pool, the maxElements form of configuration cannot be used.

*** Cache level overrides

   There will be times when the developer knows more about the tuning of each cache than and can outperform CacheManager level
   tuning. In this case it is recommended to provide cache specific configuration.

   Cache specific configuration always overrides CacheManager allocations.

   The Cache level storage pool attributes are:

    *   maxBytesOnHeap="size | %"

    *   maxBytesOffHeap="size | %"

    *   maxBytesOnDisk="size | %"

    where size is the Java -Xmx syntax. e.g. 4g and % is simply a positive number between 0 and 100. e.g. 5%

*** Overallocation Rules

    To prevent overallocation of CacheManager level pools by cache level overrdies we perform a number of checks on startup:

    *   We convert percentages to fixed amounts

    *   We then add the those to any other fixed allocations

    *   If the sum exceeds the CacheManager allocation, we throw an <<<InvalidConfigurationException>>>.

    *   If the sum equals the CacheManager allocation, we issue a warning, as there will not be memory left for caches without overrides

    Overallocations can only be detected at configuration time. For this reason we do not permit the use of max element count
    (e.g. maxElementsInMemory) configuration with CacheManager storage pools.

**  Pinning of Caches and Elements in Memory

*** Pinning of Caches

    Caches may be pinned using the new pinning sub-element:

---
   <cache name="pinnedCache"
      timeToLiveSeconds="100"
      <pinning storage="onHeap | inMemory | inCache" />
   </cache>
---

    Pinning means that cache Elements are never evicted due to space. They cache will continue to grow as elements are added to it.
    Elements will only be evicted unless the Element has expired.

    Pinning is possible at three different levels:

    *   onHeap - retain the elements in the Java heap

    *   inMemory - retain the elements in either the OnHeap or the OffHeap stores, depending on what stores there are and how much is space is available
                    in each.

    *   inCache - retain the elements in the cache. This allows further off loading to either the DiskStore in a standalone cache, or the
                  L2 in a Terracotta backed Distributed Ehcache.

    The recommended use is reference data, where you always want the whole dataset in memory.

    Pinning cannot be used with either maxElementsInMemory or maxBytesOnHeap - it is unbounded.

    Caution: It is possible to cause an OutOfMemory error with pinned caches. They may even look like a memory leak in the application.
    They are meant to be a convenience. They should not be used with potentially unbounded data sets.


*** Pinning of Elements

    Some APIs like OpenJPA and Hibernate require pinning of specific Elements.

    A new method on Element, Element.setPinned(true|false, onHeap|inMemory|inCache) has been added. When a pinned Element is placed in the cache
    it will not be evicted from the On-Heap store. Element level pinning is a noop when the whole cache is pinned.

*   Cache Warming for multi-tier Caches (Ehcache 2.5 and higher)

    When a cache starts up, the On-Heap and Off-Heap stores are always empty. Ehcache provides a BootstrapCacheLoader
    mechanism to overcome this. The BootstrapCacheLoader is run before the cache is set to alive. If synchronous, loading
    completes before the CacheManager starts, or if asynchronous, the CacheManager starts but loading continues agressively
    rather than waiting for elements to be requested, which is a lazy loading approach.

    Replicated caches provide a boot strap mechanism which populates them. For example following is the JGroups bootstrap
    cache loader:

---
<bootstrapCacheLoaderFactory
    class="net.sf.ehcache.distribution.jgroups.JGroupsBootstrapCacheLoaderFactory"
    properties="bootstrapAsynchronously=true"/>
---

    We have two new bootstrapCacheLoaderFactory implementations: one for standalone caches with DiskStores, and one for
     Terracotta Distributed caches.

**  DiskStoreBootstrapCacheLoaderFactory

    The DiskStoreBootstrapCacheLoaderFactory loads elements from the DiskStore to the On-Heap Store and the Off-Heap store
    until either:

    * the memory stores are full

    * the DiskStore has been completely loaded

*** Configuration

    The DiskStoreBootstrapCacheLoaderFactory is configured as follows:

---
<bootstrapCacheLoaderFactory
    class="net.sf.ehcache.store.DiskStoreBootstrapCacheLoaderFactory"
    properties="bootstrapAsynchronously=true"/>
---


**  TerracottaBootstrapCacheLoaderFactory

    The TerracottaBootstrapCacheLoaderFactory loads elements from the Terracotta L2 to the On-Heap Store and the Off-Heap store
    until either:

    * the memory stores are full

    * the L2 has been completely loaded

    []

    The TerracottaBootstrapCacheLoader uses knowledge of what Elements other L1s in the cluster have to predict the likely
    hot set for this L1. If this L1 is the first L1 in the cluster, then there is no guidance. The loader will then only load Elements
    from the L2 if the combined capacity of the memory stores exceeds 50% of the size in memory of the cache in the L2.

*** Configuration

    The TerracottaStoreBootstrapCacheLoaderFactory is configured as follows:

---
<bootstrapCacheLoaderFactory
    class="net.sf.ehcache.store.TerracottaStoreBootstrapCacheLoaderFactory"
    properties="bootstrapAsynchronously=true"/>
---


* {copyOnRead and copyOnWrite cache configuration}

    A cache can be configured to copy the data, rather than return reference to it on get or put. This is configured using the <<<copyOnRead>>> and <<<copyOnWrite>>>
    attributes of cache and defaultCache elements in your configuration or programmatically as follows:

---
    CacheConfiguration config = new CacheConfiguration("copyCache", 1000).copyOnRead(true).copyOnWrite(true);
    Cache copyCache = new Cache(config);
---

    The default configuration will be false for both options.

    In order to copy elements on put()-like and/or get()-like operations, a CopyStrategy is being used. The default implementation
    uses serialization to copy elements. You can provide your own implementation of <<<net.sf.ehcache.store.compound.CopyStrategy>>> like
    this:

---
    <cache name="copyCache"
           maxElementsInMemory="10"
           eternal="false"
           timeToIdleSeconds="5"
           timeToLiveSeconds="10"
           overflowToDisk="false"
           copyOnRead="true"
           copyOnWrite="true">
        <copyStrategy class="com.company.ehcache.MyCopyStrategy"/>
    </cache>
---

    Per cache, a single instance of your <<<CopyStrategy>>> will be use, hence your implementation of CopyStrategy.copy(T): T has to
    be thread-safe.

* Special System Properties

** {net.sf.ehcache.disabled}

    Setting this System Property to <<<true>>> disables caching in ehcache. If disabled no elements will be added to a cache.
    i.e. puts are silently discarded.

  e.g. <<<java -Dnet.sf.ehcache.disabled=true>>> in the Java command line.

** {net.sf.ehcache.use.classic.lru}

  Set this System property to <<<true>>> to use the older LruMemoryStore implementation
  when LRU is selected as the eviction policy.

  This is provided for ease of migration.

  e.g. <<<java -Dnet.sf.ehcache.use.classic.lru=true>>> in the Java command line.


* {ehcache.xsd}

   Ehcache configuration files must be comply with the Ehcache XML schema, ehcache.xsd.

   It can be downloaded from {{http://ehcache.org/ehcache.xsd}}.

* ehcache-failsafe.xml

    If the CacheManager default constructor or factory method is called, Ehcache looks for a
   file called ehcache.xml in the top level of the classpath. Failing that it looks for
   ehcache-failsafe.xml in the classpath. ehcache-failsafe.xml is packaged in the Ehcache jar
   and should always be found.

    ehcache-failsafe.xml provides an extremely simple default configuration to enable users to
    get started before they create their own ehcache.xml.

    If it used Ehcache will emit a warning, reminding the user to set up a proper configuration.

    The meaning of the elements and attributes are explained in the section on ehcache.xml.

---
<ehcache>
    <diskStore path="java.io.tmpdir"/>
    <defaultCache
            maxElementsInMemory="10000"
            eternal="false"
            timeToIdleSeconds="120"
            timeToLiveSeconds="120"
            overflowToDisk="true"
            maxElementsOnDisk="10000000"
            diskPersistent="false"
            diskExpiryThreadIntervalSeconds="120"
            memoryStoreEvictionPolicy="LRU"
            />
</ehcache>
---

*   Update Checker

    The update checker is used to see if you have the latest version of Ehcache. It is also used
    to get non-identifying feedback on the OS architectures using Ehcache.

    To disable the check, do one of the following:

**  By System Property

---
    -Dnet.sf.ehcache.skipUpdateCheck=true
---

**  By Configuration

    The outer <<<ehcache>>> element takes an <<<updateCheck>>> attribute, which is set to false as in the
    following example.

---
    -->
    <ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:noNamespaceSchemaLocation="ehcache.xsd"
             updateCheck="false" monitoring="autodetect"
             dynamicConfig="true">

---



* ehcache.xml and other configuration files

   Prior to ehcache-1.6, Ehcache only supported ASCII ehcache.xml configuration files.
   Since ehcache-1.6, UTF8 is supported, so that configuration can use Unicode. As UTF8 is
   backwardly compatible with ASCII, no conversion is necessary.

   If the CacheManager default constructor or factory method is called, Ehcache looks for a
   file called ehcache.xml in the top level of the classpath.

   The non-default creation methods allow a configuration file to be specified which can be
   called anything.

   One XML configuration is required for each CacheManager that is created. It is an error to
     use the same configuration, because things like directory paths and listener ports will
     conflict. Ehcache will attempt to resolve conflicts and will emit a warning reminding the
     user to configure a separate configuration for multiple CacheManagers with conflicting
     settings.

   The sample ehcache.xml is included in the Ehcache distribution. It contains full commentary required to configure each element. Further
   information can be found in specific chapters in the Guide.

   It can also be downloaded from {{http://ehcache.org/ehcache.xml}}.



