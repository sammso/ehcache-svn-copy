 ---
 Off-heap Store
 ---

{Off-heap Store}

    The off-heap store permits a cache to use a new type of memory store which is implemented using the <<<DirectByteBuffer>>> class,
    which has been available on all JVMs since JDK1.4.

    It allows very large caches to be created (we have tested up to 256GB). Because the data is stored in bytes, there are two
    implications:

    * only Serializable cache keys and values can be placed in the store, similar to DiskStore

    * Serialization and deserialization take place on putting and getting from the store. As a result, the off-heap store
      is around 10 times slower than the MemoryStore. It is still 100 times faster than the DiskStore because there is use of
      hard disk.

    The Off-heap store is only available as an the BigMemory add-on to Enterprise Ehcache.


*   Configuration

**  Configuring caches to overflow to off-heap.

    Configuring a cache to use an off-heap store can be done either through XML or programmatically.

***  Declarative Configuration

    The following XML configuration creates an offheap-cache with a in-heap store (maxElementsInMemory) of 10,000 elements which
    overflow to a 1-gigabyte off-heap area.

---
    <?xml version="1.0" encoding="UTF-8"?>
    <ehcache updateCheck="false" monitoring="off"
             dynamicConfig="false">

        <defaultCache maxElementsInMemory="10000"
                      eternal="true"
                      memoryStoreEvictionPolicy="LRU"
                      statistics="false" />

        <cache name="sample-offheap-cache"
               maxElementsInMemory="10000"
               eternal="true"
               memoryStoreEvictionPolicy="LRU"
               overflowToOffHeap="true"
               maxMemoryOffHeap="1G"/>
    </ehcache>
---

***  Programmatic Configuration

    The equivalent cache can be created using the following programmatic configuration:

---
    public Cache createOffHeapCache() {
      CacheConfiguration config = new CacheConfiguration("sample-offheap-cache", 10000).overflowToOffHeap(true).maxMemoryOffHeap("1G");
      Cache cache = new Cache(config);
      manager.addCache(cache);
      return cache;
    }
---

**   Add The License

    The Ehcache Enterprise download kit (available here - please add URL) contains a trial license key which must be added to activate
    the off-heap store.

    It can be added in two ways:

***  In the classpath

    Add the <<<terracotta.key>>> to the root of your classpath, which is also where you add ehcache.xml. It will be
    automatically found.

***  Specify the key in a Java system property

    Add a <<<org.terracotta.ehcachedx.productkey.path>>> system property which points to the key location.

    e.g.

---
     java -Dorg.terracotta.ehcachedx.productkey.path=./terracotta.key
---


**  Allocating Direct Memory in the JVM

    In order to use these configurations you must then use the ehcache-core-ee jar on your classpath, and modify your JVM command-line
    to increase the amount of direct memory allowed by the JVM.

    e.g. to allocate 2GB of memory in the JVM.

---
    java -XX:MaxDirectMemorySize=2G -cp "ehcache-core-ee-2.3.0.jar:slf4j-api-1.5.11.jar:slf4j-jdk14-1.5.11.jar"
---


*  Advanced Configuration Options

    There are some rarer configuration options which can be used for fine grained control 

**   -XX:+UseLargePages

    This is a JVM flag which is meant to improve performance of memory-hungry applications.
    In testing, this option gives a 5% speed improvement with a 1Gb off-heap cache.

**  Increasing the maximum serialized size of an Element that can be stored in the OffHeapStore

    Firstly, the MemoryStore and the DiskStore do not have any limits.

    By default, the OffHeapStore has a 4MB limit for classes with high quality hashcodes, and
    256KB for those with pathologically bad hashcodes. The built-in classes such as the
    <<<java.lang.Number>>> subclasses such as Long, Integer etc and and <<<String>>> have
    high quality hashcodes.

    You can increase the size by setting a system property cache_name.maxOffHeapValueSize to
    the size you require.

    e.g. com.company.domain.State.maxOffHeapValueSize=30MB


*   Sample application

    Download here a simple Maven-based application that uses the ehcache off-heap functionality.

    Note: You will need to get a license key as discussed above to run this.


*   Storage Hierarchy

    With the OffHeapStore, Ehcache Enterprise has three stores:

    * MemoryStore - very fast storage of Objects on heap. Limited by the size of heap you can comfortably garbage collect

    * OffHeapStore - fast (one order of magnitude slower than MemoryStore) storage of Serialized objects off heap. Limited
      only by the amount of RAM on your hardware and address space. You need a 64 bit OS to address higher than 2-4GB.

    * DiskStore - speedy storage on disk. It is two orders of magnitude slower than the OffHeapStore but still much faster
      than a database or a distributed cache


**  Storage Consumption

    As a performance optimisation, and because storage gets much cheaper as you drop down through the hierarchy, we write
    each put to as many stores as are configured. So, if all three are configured, the Element gets written to MemoryStore,
    OffHeapStore and DiskStore.

    The result is that each store consumes storage for itself and the other stores higher up the hierarchy. So, if the MemoryStore
    has 1000,000 Elements which consume 2Gb, and the OffHeapStore is configured for 8GB, then 2GB of that will be duplicate
    of what is in the MemoryStore. And the 8GB will also be duplicated on the DiskStore plus the DiskStore will have what
    cannot fit in any of the other stores.

    This needs to be taken into account when configuring the OffHeap and Disk stores.

    It has the great benefit, which pays for the duplication, of not requiring copy on eviction. On eviction from a store,
    an Element can simply be removed. It is already in the next store down.

*   Handling JVM startup and shutdown

    So you can have a huge in-process cache. But this is not a distributed cache, so when you shut down
    you will lose what is in the cache. And when you start up, how long will it take to load the cache?

    In caches up to a GB or two, these issues are not hugely problematic. You can often pre-load the cache
    on start-up before you bring the application online. Provided this only takes a few minutes, there is
    minimal operations impact.

    But when we go to tens of GBs, these startup times are O(n), and what took 2 minutes now takes 20 minutes.

    To solve this problem, we provide a new implementation of Ehcache's DiskStore, available in the enterprise
    version.

    You simply mark the cache <<<diskPersistent=true>>> as you normally would for a disk persistent cache.

    It works as follows:

    * on startup, which is immediate, the cache will get elements from disk and gradually fill the MemoryStore and
      the OffHeapStore.

    * when running elements are written to the OffHeapStore, they are already serialized. We write these to the DiskStore
      asynchronously in a write behind pattern. Tests show they can be written at a rate of 20MB/s on server class machines
      with fast disks. If writes get behind, they will back up and once they reach the <<<diskSpoolBufferSizeMB>>>
      cache puts will be slowed while the DiskStore writer catches up. By default this buffer is 30MB but can be increased
      through configuration.

    * When the Cache is disposed, only a final sync is required to
      shut the DiskStore down. Tests show that


*   FAQ

**   The DiskStore  Access stripes configuration no longer has effect. Why?

    This has been reimplemented for Ehcache Enterprise and will get added back into the core in the future.


**  What Eviction Algorithms are supported?

    The pluggable MemoryStore eviction algorithms work as normal. The OffHeapStore and DiskStore use a
    Clock Cache,a standard paging algorithm which is an approximation of LRU.

**  Why do I see performance slow down and speed up in a cyclical pattern when I am filling a cache?

    This is due to repartitioning in the OffHeapStore which is normal. Once the cache is fully filled
    the performance slow downs cease.

**  What is the maximum serialized size of an object when using OffHeapStore?

    Firstly, the MemoryStore and the DiskStore do not have any limits.

    By default, the OffHeapStore has a 4MB limit for classes with high quality hashcodes, and
    256KB for those with pathologically bad hashcodes. The built-in classes such as the
    <<<java.lang.Number>>> subclasses such as Long, Integer etc and and <<<String>>> have
    high quality hashcodes.

    You can increase the size by setting a system property cache_name.maxOffHeapValueSize to
    the size you require.

    e.g. com.company.domain.State.maxOffHeapValueSize=30MB


