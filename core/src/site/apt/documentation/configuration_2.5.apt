 ---
 Cache Configuration
 ---


{Cache Configuration}

~~%{toc|fromDepth=2|toDepth=3}

    Caches can be configured in Ehcache either declaratively, in xml, or by creating them programmatically
    and specifying their parameters in the constructor.

    While both approaches are fully supported it is generally a good idea to separate the cache configuration
    from runtime use. There are also these benefits:

     * It is easy if you have all of your configuration in one place.
       Caches consume memory, and disk space. They need to be carefully tuned.
       You can see the total effect in a configuration file. You could do this
       code, but it would not as visible.

     * Cache configuration can be changed at deployment time.

     * Configuration errors can be checked for at start-up, rather than causing a runtime error.

    This chapter covers XML declarative configuration.

    Ehcache is redistributed by lots of projects. They may or may not provide a sample Ehcache XML configuration file.
    If one is not provided, download Ehcache from {{http://ehcache.org}}. It, and the ehcache.xsd is provided in
    the distibution.


* {Dynamically Changing Cache Configuration}

    After a Cache has been started its configuration is not generally changeable. However, since Ehcache 2.0,  certain aspects of
    cache configuration can modified dynamically at runtime, namely:

    * timeToLive

    * timeToIdle

    * maxElementsInMemory

    * maxElementsOnDisk

    * memory store eviciton policy

    * CacheEventListeners can be added and removed dynamically

    This example shows how to dynamically modify the cache configuration of an already running cache:

---
    Cache cache = manager.getCache("sampleCache");
    CacheConfiguration config = cache.getCacheConfiguration();
    config.setTimeToIdleSeconds(60);
    config.setTimeToLiveSeconds(120);
    config.setMaxElementsInMemory(10000);
    config.setMaxElementsOnDisk(1000000);
---

    Dynamic cache configurations can also be frozen to prevent future changes:

---
    Cache cache = manager.getCache("sampleCache");
    cache.disableDynamicFeatures();
---


*   Memory Based Cache Sizing

    Historically Ehcache has only permitted sizing of caches by maxElementsInMemory for the the Heap Store
    The OffHeap Store is sized in terms of memory using maxMemoryOffHeap.

    From Ehcache 2.5, we are introducing sizing based on memory use for the MemoryStore (on Heap). The new attribute is maxMemoryOnHeap.

    For added simplicity you can also specify these attributes at the ehcache level, which then applies them to the whole CacheManager,
    leaving each cache to share in one large pool of memory.

    For completeness we also add cache pinning and rules for cache-level configuration to override CacheManager level configuration.

    The Off-heap store also gets a CacheManager wide maxMemoryOffHeap

     To Do:
     1. Use maxBytes...
     2. DiskStore
     3. Use percentages as well

**  Example Configuration

    An example is shown below. It allocates 1GB on heap and 4GB off heap at the CacheManager level.

    It also demonstrates some finer points which we will conver in the following sections.

---
    <ehcache maxMemoryOnHeap="1g" maxMemoryOffHeap="4g" >

       <cache name="explicitlyAllocatedCache"
              maxMemoryOnHeap="50m"
              maxMemoryOffHeap="200m"
              timeToLiveSeconds="100"
       </cache>

       <cache name="automaticallyAllocatedCache1"
              timeToLiveSeconds="100"
       </cache>

       <cache name="automaticallyAllocatedCache2"
              timeToLiveSeconds="100"
       </cache>

       <cache name="maxElementsCache"
              maxElementsInMemory="10000" illegal
              timeToLiveSeconds="100"
       </cache>

       <cache name="pinnedCache"
              timeToLiveSeconds="100"
              <pinning maxElementsInMemory=ÓÓ />
       </cache>

    </ehcache>
---



** CacheManager versus Cache level configuration

    Caches without specific configuration participate in the general pool of memory. An Element from any cache can be evicted
    which uses an LRU (possibly clock based) algorithm.

*** Cache level sizing


   There will be times when the developer knows more about the relative value of each cache such that they should not be treated
   equally. In this case it is recommended to provide cache specific configuration.

   Cache specific configuration always overrides CacheManager allocations.

   You have a choice of configuring the size of a cache with:

   * maxElementsInMemory. Note however that you cannot mix maxElementsInMemory with CacheManager level configuration.

   * maxMemoryOnHeap.


*** Overallocation

    One unintended result is overallocation, where specific configurations exceed that available to the CacheManager. As with the Off-Heap
    store the configuration is checked at startup. If there is an overallocation an InvalidConfigurationException is thrown.

    Secondly, if zero memory is left for pool allocated caches, a warning is issued. These run the risk of being starved for memory
    once the specifically configured caches fill up.

    Overallocations can only be detected at configuration time when they are memory based. For that reason maxElementsInMemory can
    only be used if the CacheManager level maxMemoryOnHeap is not used.

**  Pinning of Caches and Elements in Memory

*** Pinning of Caches

    Caches may be pinned using the new pinning sub-element:

---
   <cache name="pinnedCache"
      timeToLiveSeconds="100"
      <pinning store=ÓonHeap|inMemory|inCacheÓ />
   </cache>
---

    Pinning means that the cache Elements are never evicted due to space. They will continue to grow and Elements will not be evicted unless
    the Element has expired.

    Pinning is to memory. Elements are allowed to be evicted from the OnHeap store and moved to the OffHeap store, but not to the DiskStore
    or the L2 in distributed Ehcache.

    The recommended use is reference data, where you always want the whole dataset in memory.

    Pinning cannot be used with maxElementsInMemory or maxMemoryOnHeap.


*** Pinning of Elements

    Some APIs like OpenJPA and Hibernate require pinning of specific Elements.

    A new method on Element, Element.setPinned(true|false, onHeap|inMemory|inCache) has been added. When a pinned Element is placed in the cache
    it will not be evicted from the On-Heap store.

*   Cache Warming for Tiered, Distributed Caches

    When a cache starts up, the On-Heap and Off-Heap stores are always empty. Ehcache provides a BootstrapCacheLoader
    mechanism to overcome this. The BootstrapCacheLoader is run before the cache is set to alive. If synchronous, loading
    completes before the CacheManager starts, or if asynchronous, the CacheManager starts but loading continues agressively
    rather than waiting for elements to be requested, which is a lazy loading approach.

    Replicated caches provide a boot strap mechanism which populates them. For example following is the JGroups bootstrap
    cache loader:

---
    <bootstrapCacheLoaderFactory class="net.sf.ehcache.distribution.jgroups.JGroupsBootstrapCacheLoaderFactory"
                                        properties="bootstrapAsynchronously=true"/>
---

    We have two new bootstrapCacheLoaderFactory implementations: one for standalone caches with DiskStores, and one for
     Terracotta Distributed caches.

**  DiskStoreBootstrapCacheLoaderFactory

    The DiskStoreBootstrapCacheLoaderFactory loads elements from the DiskStore to the On-Heap Store and the Off-Heap store
    until either:

    * the memory stores are full

    * the DiskStore has been completely loaded

*** Configuration

    The DiskStoreBootstrapCacheLoaderFactory is configured as follows:

---
    <bootstrapCacheLoaderFactory class="net.sf.ehcache.store.DiskStoreBootstrapCacheLoaderFactory"
                                        properties="bootstrapAsynchronously=true"/>
---


**  TerracottaBootstrapCacheLoaderFactory

    The TerracottaBootstrapCacheLoaderFactory loads elements from the Terracotta L2 to the On-Heap Store and the Off-Heap store
    until either:

    * the memory stores are full

    * the L2 has been completely loaded

    []

    The TerracottaBootstrapCacheLoader uses knowledge of what Elements other L1s in the cluster have to predict the likely
    hot set for this L1. If this L1 is the first L1 in the cluster, then there is no guidance. The loader will then only load Elements
    from the L2 if the combined capacity of the memory stores exceeds 50% of the size in memory of the cache in the L2.

*** Configuration

    The TerracottaStoreBootstrapCacheLoaderFactory is configured as follows:

---
    <bootstrapCacheLoaderFactory class="net.sf.ehcache.store.TerracottaStoreBootstrapCacheLoaderFactory"
                                        properties="bootstrapAsynchronously=true"/>
---


* {copyOnRead and copyOnWrite cache configuration}

    A cache can be configured to copy the data, rather than return reference to it on get or put. This is configured using the <<<copyOnRead>>> and <<<copyOnWrite>>>
    attributes of cache and defaultCache elements in your configuration or programmatically as follows:

---
    CacheConfiguration config = new CacheConfiguration("copyCache", 1000).copyOnRead(true).copyOnWrite(true);
    Cache copyCache = new Cache(config);
---

    The default configuration will be false for both options.

    In order to copy elements on put()-like and/or get()-like operations, a CopyStrategy is being used. The default implementation
    uses serialization to copy elements. You can provide your own implementation of <<<net.sf.ehcache.store.compound.CopyStrategy>>> like
    this:

---
    <cache name="copyCache"
           maxElementsInMemory="10"
           eternal="false"
           timeToIdleSeconds="5"
           timeToLiveSeconds="10"
           overflowToDisk="false"
           copyOnRead="true"
           copyOnWrite="true">
        <copyStrategy class="com.company.ehcache.MyCopyStrategy"/>
    </cache>
---

    Per cache, a single instance of your <<<CopyStrategy>>> will be use, hence your implementation of CopyStrategy.copy(T): T has to
    be thread-safe.

* Special System Properties

** {net.sf.ehcache.disabled}

    Setting this System Property to <<<true>>> disables caching in ehcache. If disabled no elements will be added to a cache.
    i.e. puts are silently discarded.

  e.g. <<<java -Dnet.sf.ehcache.disabled=true>>> in the Java command line.

** {net.sf.ehcache.use.classic.lru}

  Set this System property to <<<true>>> to use the older LruMemoryStore implementation
  when LRU is selected as the eviction policy.

  This is provided for ease of migration.

  e.g. <<<java -Dnet.sf.ehcache.use.classic.lru=true>>> in the Java command line.


* {ehcache.xsd}

   Ehcache configuration files must be comply with the Ehcache XML schema, ehcache.xsd.

   It can be downloaded from {{http://ehcache.org/ehcache.xsd}}.

* ehcache-failsafe.xml

    If the CacheManager default constructor or factory method is called, Ehcache looks for a
   file called ehcache.xml in the top level of the classpath. Failing that it looks for
   ehcache-failsafe.xml in the classpath. ehcache-failsafe.xml is packaged in the Ehcache jar
   and should always be found.

    ehcache-failsafe.xml provides an extremely simple default configuration to enable users to
    get started before they create their own ehcache.xml.

    If it used Ehcache will emit a warning, reminding the user to set up a proper configuration.

    The meaning of the elements and attributes are explained in the section on ehcache.xml.
    
---
<ehcache>
    <diskStore path="java.io.tmpdir"/>
    <defaultCache
            maxElementsInMemory="10000"
            eternal="false"
            timeToIdleSeconds="120"
            timeToLiveSeconds="120"
            overflowToDisk="true"
            maxElementsOnDisk="10000000"
            diskPersistent="false"
            diskExpiryThreadIntervalSeconds="120"
            memoryStoreEvictionPolicy="LRU"
            />
</ehcache>
---

*   Update Checker

    The update checker is used to see if you have the latest version of Ehcache. It is also used 
    to get non-identifying feedback on the OS architectures using Ehcache.

    To disable the check, do one of the following:

**  By System Property

---
    -Dnet.sf.ehcache.skipUpdateCheck=true
---

**  By Configuration

    The outer <<<ehcache>>> element takes an <<<updateCheck>>> attribute, which is set to false as in the
    following example.

---
    -->
    <ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:noNamespaceSchemaLocation="ehcache.xsd"
             updateCheck="false" monitoring="autodetect"
             dynamicConfig="true">

---



* ehcache.xml and other configuration files

   Prior to ehcache-1.6, Ehcache only supported ASCII ehcache.xml configuration files.
   Since ehcache-1.6, UTF8 is supported, so that configuration can use Unicode. As UTF8 is
   backwardly compatible with ASCII, no conversion is necessary.

   If the CacheManager default constructor or factory method is called, Ehcache looks for a
   file called ehcache.xml in the top level of the classpath.

   The non-default creation methods allow a configuration file to be specified which can be
   called anything.

   One XML configuration is required for each CacheManager that is created. It is an error to
     use the same configuration, because things like directory paths and listener ports will
     conflict. Ehcache will attempt to resolve conflicts and will emit a warning reminding the
     user to configure a separate configuration for multiple CacheManagers with conflicting
     settings.

   The sample ehcache.xml is included in the Ehcache distribution. It contains full commentary required to configure each element. Further
   information can be found in specific chapters in the Guide.

   It can also be downloaded from {{http://ehcache.org/ehcache.xml}}.



