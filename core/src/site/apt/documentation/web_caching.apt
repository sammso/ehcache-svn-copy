{Web Caching}

* {CachingFilter}

    You want to use the BlockingCache with web pages, but the requirement to always release the lock creates gnarly code.
    You also want to think about what you are doing withs involved. This is on every jsp:include and every Servlet. And you can
    programmatically add your own. If you have content generated by JSP, Velocity, FreeMarker, String Template, XSLT, Servlet output or anything else,
    it can all be cached by CachingFilter. A separation of concerns.

    How do you determine what the key of a page is? The filter has an abstract calculateKey method, so it is up to you.

    You notice a problem and an opportunity. The problem is that the web pages you are caching are huge. That chews up
    either a lot of memory (Memoryout thinking about the caching.

    Enter the CachingFilter, a Servlet 2.5 compliant filter. Why not just do a JSP tag library, like OSCache? The answer
    is that you want the caching of your responses to be independent of the rendering technology. The filter chain is
    reexcuted every time a RequestDispatcher iStore) or a lot of disk space (DiskStore). Also you notive that these pages take their
    time going over the Internet. The opportunity is that you notice that all modern browsers support gzip encoding. A survey
    of logs reveals that 85% of the time the browser accepts gzipping. (The majority of the 15% that does not is IE
    behind a proxy). Ok, so gzip the response before caching it. Ungzipping is fast - so just ungzip for the 15% of the
    time the browser does not accept gzipping.

    Pages are stored based on the key determined by a <<<calculateKey>>> method. This method enables implementations
    to exclude referral query parameters which have no bearing on the result to be returned.


* Concurrent Cache Miss Requests

    The CachingFilter queues multiple requests for the same key, so that the downsteam infrastructure only has to
    do the work once, and moreover, so that it does not get overwhelmed on very busy sites.

    

* {SimplePageCachingFilter}

    What if you just want to get started with the CachingFilter and don't want to think too hard? Just use SimplePageCachingFilter
    which has a calculateKey method already implemented.

    It uses <<<httpRequest.getRequestURI()).append(httpRequest.getQueryString()>>> for the key. This works most of the time. It tends to get less effective when referrals and affiliates are added to the query,
    which is the case for a lot of e-commerce sites.

    SimplePageCachingFilter is 10 lines of code.
    
    If you use this default implementation, the cache name is called "SimplePageCachingFilter". You need to define a cache with that
     name in ehcache.xml.



* {SimpleCachingHeadersPageCachingFilter}

  This Filter extends SimplePageCachingFilter, adding support for
  the HTTP cache headers, ETag, Last-Modified, Expires, and If-None-Match.

  Because browsers and other HTTP clients have the expiry information returned in the response headers,
  they do not even need to request the page again. Even once the local browser copy has expired, the browser
  will do a conditional GET.

  So why would you ever want to use SimplePageCachingFilter, which does not set these headers? Because in some caching
  scenarios you may wish to remove a page before its natural expiry. Consider a scenario where a web page shows dynamic
  data. Under ehcache the Element can be removed at any time. However if a browser is holding expiry information, those
  browsers will have to wait until the expiry time before getting updated. The caching in this scenario is more about
  defraying server load rather than minimising browser calls.

* {PageFragmentCachingFilter}

    You notice that an entire page cannot be cached because the data on it vary in staleness. Say, an address which changes
    very infrequently, and the price and availability of inventory, which changes quite a lot. Or you have a portal, with
    lots of components and with different stalenesses. Or you use the replicated cache functionality in ehcache and you
    only want to rebuild the part of the page that got invalidated.

    Enter the PageFragmentCachingFilter. It does everyting that SimplePageCachingFilter does, except it never
    gzips, so the fragments can be combined.


* {SimplePageFragmentCachingFilter}

    What if you just want to get started with the PageFragmentCachingFilter and don't want to think too hard? Just use SimplePageFragmentCachingFilter
    which has a calculateKey method already implemented. It uses <<<httpRequest.getRequestURI()).append(httpRequest.getQueryString()>>>
    for the key. This works most of the time. It tends to get less effective when referrals and affiliates are added to the query,
    which is the case for a lot of e-commerce sites.

